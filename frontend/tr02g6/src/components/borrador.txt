const communicationManager = new CommunicationManager("http://localhost:3000/api"); 
    const data = {
        central: { id: "1", class: "1", name: "Carlos" },
        fields: [
            {
                name: "Agressivitat",
                subfields: [
                    { name: "Física", value: 8 },
                    { name: "Verbal", value: 0 },
                    { name: "Relacional", value: 4 }
                ]
            },
            {
                name: "Prosocialitat",
                value: 4 // No tiene subcampos
            },
            {
                name: "Victimització",
                subfields: [
                    { name: "Física", value: 2 },
                    { name: "Verbal", value: 5 },
                    { name: "Relacional", value: 11 }
                ]
            },
            {
                name: "Popularitat",
                subfields: [
                    { name: "Popular", value: "X" },
                    { name: "Rebutjat", value: " " },
                    { name: "Ignorat", value: " " },
                    { name: "Controvertit", value: " " },
                    { name: "Norma", value: " " }
                ]
            }
        ]
    };

    const svg = d3.select("svg");
    const width = +svg.attr("width");
    const height = +svg.attr("height");

    const centralRadius = 50;
    const fieldRadius = 100;
    const subfieldScale = d3.scaleSqrt().domain([0, 20]).range([10, 40]);

    // Central circle
    const centralGroup = svg.append("g")
        .attr("class", "main-circle")
        .attr("transform", `translate(${width / 2}, ${height / 2})`);

    centralGroup.append("circle")
        .attr("r", centralRadius)
        .attr("fill", "lightblue");

    centralGroup.append("text")
        .attr("dy", ".35em")
        .text(data.central.name);

    // Position fields around central circle
    const angleScale = d3.scaleLinear()
        .domain([0, data.fields.length])
        .range([0, 2 * Math.PI]);

    let fieldsToShow = data.fields.flatMap(field => {
        if (field.name === "Popularitat") {
            // Mostrar solo el subcampo con "X" en Popularitat
            const activeField = field.subfields.find(subfield => subfield.value === "X");
            return activeField ? [{ name: field.name, value: activeField.name }] : [];
        } else if (field.subfields) {
            // Mostrar todos los campos con subcampos normales
            return [field];
        } else {
            // Mostrar campos sin subcampos como Prosocialitat
            return [field];
        }
    });

    fieldsToShow.forEach((field, i) => {
        const angle = angleScale(i);
        const x = width / 2 + Math.cos(angle) * 200;
        const y = height / 2 + Math.sin(angle) * 200;

        const fieldGroup = svg.append("g")
            .attr("class", "field-group")
            .attr("transform", `translate(${x}, ${y})`);

        // Field circle
        fieldGroup.append("circle")
            .attr("r", fieldRadius)
            .attr("fill", "lightgray");

        // Field label
        fieldGroup.append("text")
            .attr("dy", ".35em")
            .text(field.name);

        // Subfields
        if (field.subfields) {
            const subAngleScale = d3.scaleLinear()
                .domain([0, field.subfields.length])
                .range([0, 2 * Math.PI]);

            field.subfields.forEach((subfield, j) => {
                const subAngle = subAngleScale(j);
                const subX = Math.cos(subAngle) * (fieldRadius - 20);
                const subY = Math.sin(subAngle) * (fieldRadius - 20);

                const subRadius = subfieldScale(subfield.value || 1); // Default size for non-numeric values

                const subGroup = fieldGroup.append("g")
                    .attr("class", "subfield-group")
                    .attr("transform", `translate(${subX}, ${subY})`);

                subGroup.append("circle")
                    .attr("r", subRadius)
                    .attr("fill", "white")
                    .attr("stroke", "black");

                subGroup.append("text")
                    .attr("dy", ".35em")
                    .text(subfield.name);

                subGroup.append("text")
                    .attr("dy", "1.5em")
                    .text(subfield.value);
            });
        } else if (field.value !== undefined) {
            // For fields without subfields (e.g., Prosocialitat or Popularitat)
            fieldGroup.append("text")
                .attr("dy", "1.5em")
                .text(field.value);
        }
    });

    "class CommunicationManager {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  // Método genérico para realizar fetch
  async fetchData(endpoint, options = {}) {
    try {
      const response = await fetch(`${this.baseURL}${endpoint}`, options);
      if (!response.ok) {
        throw new Error(`Error: ${response.status} ${response.statusText}`);
      }
      return await response.json();
    } catch (error) {
      console.error(`Fetch error: ${error}`);
      throw error;
    }
  }

  // Métodos específicos para las tablas
  getRespostes() {
    return this.fetchData("/respostes");
  }

  getRespostesProcessades() {
    return this.fetchData("/respostes_processades");
  }

  getResultats() {
    return this.fetchData("/resultats");
  }

  postData(endpoint, data) {
    return this.fetchData(endpoint, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data),
    });
  }
}"